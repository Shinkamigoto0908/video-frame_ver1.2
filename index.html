<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Trace Frame Tool</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
body {
  margin: 0;
  font-family: sans-serif;
  background: #f5f5f5;
}

#controls {
  padding: 10px;
  background: #fff;
  position: sticky;
  top: 0;
  z-index: 20;
}

#previewWrap {
  position: relative;
  height: 60vh;
  background: #000;
  overflow: hidden;
}

#cameraBg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.5;
}

#preview {
  position: absolute;
  left: 50%;
  top: 50%;
  touch-action: none;
}

#timeline {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 10px;
  background: #ddd;
}

.thumb {
  flex: 0 0 auto;
  text-align: center;
}

.thumb img {
  width: 80px;
  border: 2px solid transparent;
}

.thumb.active img {
  border-color: red;
}
</style>
</head>

<body>

<div id="controls">
  <input type="file" id="file" accept="video/*">
  fps <input type="number" id="fps" value="6" min="1" max="30">
  <button id="build">生成</button>
  <button id="zip">ZIP DL</button>
</div>

<div id="previewWrap">
  <video id="cameraBg" autoplay muted playsinline></video>
  <canvas id="preview"></canvas>
</div>

<div id="timeline"></div>

<video id="video" style="display:none"></video>
<canvas id="work" style="display:none"></canvas>

<script>
const cameraBg = document.getElementById("cameraBg");

/* ===== 背面カメラ指定 ===== */
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } },
      audio: false
    });
    cameraBg.srcObject = stream;
  } catch (e) {
    // フォールバック（指定失敗時）
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });
    cameraBg.srcObject = stream;
  }
}
startCamera();

/* ===== 描画関連 ===== */
const video = document.getElementById("video");
const work = document.getElementById("work");
const wctx = work.getContext("2d");
const preview = document.getElementById("preview");
const pctx = preview.getContext("2d");
const timeline = document.getElementById("timeline");

let frames = [];
let currentImg = null;
let transform = { x:0, y:0, scale:1 };
let dragging = false;
let start = {x:0,y:0};

/* ===== ドラッグ移動 ===== */
preview.addEventListener("pointerdown", e=>{
  dragging = true;
  start.x = e.clientX - transform.x;
  start.y = e.clientY - transform.y;
});
window.addEventListener("pointerup", ()=>dragging=false);
window.addEventListener("pointermove", e=>{
  if(!dragging) return;
  transform.x = e.clientX - start.x;
  transform.y = e.clientY - start.y;
  drawPreview();
});

/* ===== ホイール拡縮 ===== */
preview.addEventListener("wheel", e=>{
  e.preventDefault();
  transform.scale *= e.deltaY < 0 ? 1.05 : 0.95;
  drawPreview();
},{passive:false});

function drawPreview(){
  pctx.setTransform(1,0,0,1,0,0);
  pctx.clearRect(0,0,preview.width,preview.height);
  if(!currentImg) return;

  pctx.setTransform(
    transform.scale,0,0,transform.scale,
    preview.width/2 + transform.x,
    preview.height/2 + transform.y
  );
  pctx.drawImage(
    currentImg,
    -currentImg.width/2,
    -currentImg.height/2
  );
}

/* ===== 動画読み込み ===== */
document.getElementById("file").onchange = e=>{
  video.src = URL.createObjectURL(e.target.files[0]);
};

/* ===== フレーム生成 ===== */
document.getElementById("build").onclick = async ()=>{
  timeline.innerHTML="";
  frames=[];
  transform={x:0,y:0,scale:1};

  const fps = Number(document.getElementById("fps").value)||6;
  const step = 1/fps;

  await video.play(); video.pause();

  work.width = preview.width = video.videoWidth;
  work.height = preview.height = video.videoHeight;

  let t=0;
  while(t<video.duration){
    video.currentTime=t;
    await new Promise(r=>video.onseeked=r);

    wctx.drawImage(video,0,0);
    const blob = await new Promise(r=>work.toBlob(r));
    frames.push(blob);

    const img = new Image();
    img.src = URL.createObjectURL(blob);
    await img.decode();

    const d = document.createElement("div");
    d.className="thumb";
    d.innerHTML=`<img src="${img.src}"><div>${t.toFixed(2)}s</div>`;
    d.onclick=()=>{
      document.querySelectorAll(".thumb").forEach(x=>x.classList.remove("active"));
      d.classList.add("active");
      currentImg = img;
      drawPreview();
    };
    timeline.appendChild(d);
    if(frames.length===1)d.onclick();
    t+=step;
  }
};

/* ===== ZIP ダウンロード ===== */
document.getElementById("zip").onclick = async ()=>{
  const zip = new JSZip();

  for(let i=0;i<frames.length;i++){
    const img = new Image();
    img.src = URL.createObjectURL(frames[i]);
    await img.decode();

    wctx.setTransform(1,0,0,1,0,0);
    wctx.clearRect(0,0,work.width,work.height);
    wctx.setTransform(
      transform.scale,0,0,transform.scale,
      work.width/2 + transform.x,
      work.height/2 + transform.y
    );
    wctx.drawImage(img,-img.width/2,-img.height/2);

    const b = await new Promise(r=>work.toBlob(r));
    zip.file(`frame_${i}.png`, b);
  }

  const blob = await zip.generateAsync({type:"blob"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "frames.zip";
  a.click();
};
</script>

</body>
</html>
